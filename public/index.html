<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FTIR Merger</title>
  <link rel="stylesheet" href="styles.css">
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
</head>
<body>
  <div class="card">
    <div class="form-section">
      <div>
        <h1 data-i18n="title">FTIR TXT → CSV</h1>
        <p data-i18n="description" style="margin:4px 0 0 0;">Select multiple .txt files (FTIR spectra), set file name, merge to CSV, save a copy, and view the chart.</p>
      </div>
      <div class="lang-switch">
        <a href="#" class="lang-link" data-lang="en">EN</a>
        <a href="#" class="lang-link" data-lang="ru">RU</a>
        <a href="#" class="lang-link" data-lang="sr">SR</a>
      </div>
    </div>
    <div>
      <label for="files" data-i18n="filesLabel">Files (.txt):</label>
      <input id="files" type="file" accept=".txt" multiple>

      <label for="sampleIndex" data-i18n="sampleIndex">Sample index (optional):</label>
      <input id="sampleIndex" type="text" placeholder="e.g. A1">

      <label for="fileName" data-i18n="fileName">Output file name (.csv):</label>
      <input id="fileName" type="text" value="merged.csv">

      <div style="margin-top:12px; display:flex; gap:12px; flex-wrap:wrap;">
        <label style="display:flex; align-items:center; gap:6px;">
          <span data-i18n="autoDownload">Auto-download:</span>
          <input id="autoDownload" type="checkbox" checked>
        </label>
      </div>

      <button id="mergeBtn" data-i18n="mergeBtn">Merge</button>
      <div id="status"></div>
      <div id="downloadLink"></div>
    </div>

    <div class="chart-row" id="chartRow" style="display:none;">
      <div id="chart"></div>
      <div id="chartLegend" class="legend"></div>
      <div id="chartControls" class="controls">
        <h3 data-i18n="chartSettings">Chart settings</h3>
        <div class="control-group">
          <label data-i18n="xRange">X range (reverse):</label>
          <div style="display:flex; gap:8px;">
            <input id="xMax" type="number" value="4000" step="1" style="width:90px" disabled>
            <span style="align-self:center;">→</span>
            <input id="xMin" type="number" value="500" step="1" style="width:90px" disabled>
          </div>
        </div>
        <div class="control-group">
          <label data-i18n="yRange">Y range:</label>
          <div style="display:flex; gap:8px;">
            <input id="yMin" type="number" step="0.1" placeholder="auto" style="width:90px" disabled>
            <span style="align-self:center;">→</span>
            <input id="yMax" type="number" step="0.1" placeholder="auto" style="width:90px" disabled>
          </div>
        </div>
        <button id="refreshChart" type="button" disabled style="margin-top:8px;" data-i18n="refresh">Refresh chart</button>
        <button id="saveCsv" type="button" disabled style="margin-top:8px; background:#16a34a;" data-i18n="saveCsv">Save CSV</button>
      </div>
    </div>
  </div>

  <script>
    const fileInput = document.getElementById('files');
    const mergeBtn = document.getElementById('mergeBtn');
    const statusEl = document.getElementById('status');
    const chartEl = document.getElementById('chart');
    const sampleInput = document.getElementById('sampleIndex');
    const fileNameInput = document.getElementById('fileName');
    const autoDownloadInput = document.getElementById('autoDownload');
    const downloadLinkEl = document.getElementById('downloadLink');
    const refreshBtn = document.getElementById('refreshChart');
    const xMinInput = document.getElementById('xMin');
    const xMaxInput = document.getElementById('xMax');
    const yMinInput = document.getElementById('yMin');
    const yMaxInput = document.getElementById('yMax');
    const saveCsvBtn = document.getElementById('saveCsv');
    const chartRow = document.getElementById('chartRow');
    const chartLegend = document.getElementById('chartLegend');
    const i18nTargets = document.querySelectorAll('[data-i18n]');
    const langLinks = document.querySelectorAll('.lang-link');

    const translations = {
      en: {
        title: 'FTIR TXT → CSV',
        description: 'Select multiple .txt files (FTIR spectra), set file name, merge to CSV, save a copy, and view the chart.',
        filesLabel: 'Files (.txt):',
        sampleIndex: 'Sample index (optional):',
        fileName: 'Output file name (.csv):',
        autoDownload: 'Auto-download:',
        mergeBtn: 'Merge',
        chartSettings: 'Chart settings',
        xRange: 'X range (reverse):',
        yRange: 'Y range:',
        offsetsLabel: 'Y offsets per curve:',
        refresh: 'Refresh chart',
        saveCsv: 'Save CSV',
        statusNoFiles: 'Add at least one file.',
        statusReading: 'Reading files...',
        statusSending: 'Merging...',
        statusDoneDownload: 'Done! CSV downloaded. Drawing chart...',
        statusDoneLink: 'Done! Download link ready. Drawing chart...',
        statusSaved: (p) => `Saved: ${p}`,
        statusSaveCanceled: 'Save canceled.',
        statusNoDataCols: 'No data columns found (only wavenumber?)',
        statusNoNumeric: 'No numeric data to plot.',
        language: 'Language:',
      },
      ru: {
        title: 'FTIR TXT → CSV',
        description: 'Выберите несколько .txt файлов (спектры ФТИР), задайте имя, объедините, сохраните копию и смотрите график.',
        filesLabel: 'Файлы (.txt):',
        sampleIndex: 'Индекс образца (опционально):',
        fileName: 'Имя итогового файла (.csv):',
        autoDownload: 'Автоскачивание:',
        mergeBtn: 'Объединить',
        chartSettings: 'Настройки диаграммы',
        xRange: 'Диапазон X (реверс):',
        yRange: 'Диапазон Y:',
        offsetsLabel: 'Смещения по Y для кривых:',
        refresh: 'Обновить график',
        saveCsv: 'Сохранить CSV',
        statusNoFiles: 'Добавьте хотя бы один файл.',
        statusReading: 'Чтение файлов...',
        statusSending: 'Объединение...',
        statusDoneDownload: 'Готово! CSV скачан. Рисую график...',
        statusDoneLink: 'Готово! Ссылка готова. Рисую график...',
        statusSaved: (p) => `Сохранено: ${p}`,
        statusSaveCanceled: 'Сохранение отменено.',
        statusNoDataCols: 'Не удалось найти столбцы данных (только wavenumber?)',
        statusNoNumeric: 'Нет числовых данных для построения графика.',
        language: 'Язык:',
        yAuto: 'auto',
      },
      sr: {
        title: 'FTIR TXT → CSV',
        description: 'Izaberite više .txt fajlova (FTIR spektri), unesite ime, spojite u CSV, sačuvajte kopiju i pogledajte graf.',
        filesLabel: 'Fajlovi (.txt):',
        sampleIndex: 'Indeks uzorka (opciono):',
        fileName: 'Naziv izlaznog fajla (.csv):',
        autoDownload: 'Auto preuzimanje:',
        mergeBtn: 'Spoji',
        chartSettings: 'Podešavanja grafa',
        xRange: 'Opseg X (obrnuto):',
        yRange: 'Opseg Y:',
        offsetsLabel: 'Pomeraj po Y za krive:',
        refresh: 'Osveži graf',
        saveCsv: 'Sačuvaj CSV',
        statusNoFiles: 'Dodajte bar jedan fajl.',
        statusReading: 'Čitanje fajlova...',
        statusSending: 'Spajanje...',
        statusDoneDownload: 'Gotovo! CSV preuzet. Crtam graf...',
        statusDoneLink: 'Gotovo! Link spreman. Crtam graf...',
        statusSaved: (p) => `Sačuvano: ${p}`,
        statusSaveCanceled: 'Čuvanje otkazano.',
        statusNoDataCols: 'Nema kolona sa podacima (samo wavenumber?)',
        statusNoNumeric: 'Nema numeričkih podataka za graf.',
        language: 'Jezik:',
        yAuto: 'auto',
      },
    };

    const browserLang = ((navigator.language || 'en').slice(0, 2) || 'en').toLowerCase();
    let currentLang = ['ru', 'sr'].includes(browserLang) ? browserLang : 'en';

    function t(key, arg) {
      const dict = translations[currentLang] || translations.en;
      const val = dict[key];
      return typeof val === 'function' ? val(arg) : (val || translations.en[key] || key);
    }

    function applyTranslations() {
      i18nTargets.forEach((el) => {
        const key = el.getAttribute('data-i18n');
        if (key) el.textContent = t(key);
      });
      sampleInput.placeholder = currentLang === 'ru' ? 'например, A1' : currentLang === 'sr' ? 'npr. A1' : 'e.g. A1';
      yMinInput.placeholder = t('yAuto') || 'auto';
      yMaxInput.placeholder = t('yAuto') || 'auto';
      langLinks.forEach((link) => {
        link.classList.toggle('active', link.dataset.lang === currentLang);
      });
      document.documentElement.lang = currentLang;
    }

    function setLanguage(lang) {
      currentLang = ['en', 'ru', 'sr'].includes(lang) ? lang : 'en';
      applyTranslations();
    }

    langLinks.forEach((link) => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        setLanguage(link.dataset.lang);
      });
    });
    applyTranslations();

    let lastData = null; // [{file, x, y}]
    let offsets = new Map(); // file -> offset
    let lastCsvText = '';
    let visibleSeries = new Map(); // file -> boolean

    function setStatus(msg, isError = false) {
      statusEl.textContent = msg;
      statusEl.style.color = isError ? '#b91c1c' : '#111';
    }

    function readFileText(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsText(file);
      });
    }

    function generateName() {
      const files = Array.from(fileInput.files || []);
      const count = files.length;
      const now = new Date();
      const pad = (n) => String(n).padStart(2, '0');
      const date = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}`;
      const sample = (sampleInput.value || '').trim();
      const base = `ftir_${date}_${count || 0}files${sample ? `_${sample}` : ''}`;
      const withExt = base.toLowerCase().endsWith('.csv') ? base : `${base}.csv`;
      fileNameInput.value = withExt;
    }

    fileInput.addEventListener('change', generateName);
    sampleInput.addEventListener('input', generateName);
    generateName();

    function renderChartFromData(data) {
      if (!window.d3) return;
      const filtered = data.filter((d) => typeof d.x === 'number' && typeof d.y === 'number' && d.x <= 4000 && d.x >= 500);
      if (!filtered.length) {
        chartEl.innerHTML = '<p>No data in 4000–500.</p>';
        chartLegend.innerHTML = '';
        return;
      }

      const allSeries = Array.from(new Set(filtered.map((d) => d.file)));

      // apply visibility
      const filteredVisible = filtered.filter((d) => visibleSeries.get(d.file) !== false);
      const byFile = d3.group(filteredVisible, (d) => d.file);
      const yDomainAuto = d3.extent(filtered, (d) => d.y);
      const xMaxVal = Number(xMaxInput.value) || 4000;
      const xMinVal = Number(xMinInput.value) || 500;
      const yMinVal = yMinInput.value === '' ? yDomainAuto[0] : Number(yMinInput.value);
      const yMaxVal = yMaxInput.value === '' ? yDomainAuto[1] : Number(yMaxInput.value);
      const margin = { top: 20, right: 20, bottom: 40, left: 60 };
      const width = chartEl.clientWidth || 800;
      const height = 420;
      const innerW = width - margin.left - margin.right;
      const innerH = height - margin.top - margin.bottom;

      const x = d3.scaleLinear().domain([xMaxVal, xMinVal]).range([0, innerW]);
      const y = d3.scaleLinear().domain([yMinVal, yMaxVal]).nice().range([innerH, 0]);

      const line = d3.line()
        .x((d) => x(d.x))
        .y((d) => y(d.y))
        .defined((d) => Number.isFinite(d.x) && Number.isFinite(d.y))
        .curve(d3.curveLinear);

      const svg = d3.create('svg').attr('viewBox', `0 0 ${width} ${height}`);
      const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

      g.append('g')
        .attr('transform', `translate(0,${innerH})`)
        .call(d3.axisBottom(x));
      g.append('g')
        .call(d3.axisLeft(y));

      const color = d3.scaleOrdinal(d3.schemeTableau10).domain(allSeries);
      const allPoints = [];

      for (const [file, rows] of byFile) {
        const offset = offsets.get(file) || 0;
        const sorted = rows.slice().sort((a, b) => b.x - a.x).map((d) => ({ ...d, y: d.y + offset, file }));
        g.append('path')
          .datum(sorted)
          .attr('fill', 'none')
          .attr('stroke', color(file))
          .attr('stroke-width', 1.5)
          .attr('d', line);
        allPoints.push(...sorted);
      }

      // HTML legend with offsets
      chartLegend.innerHTML = '';
      for (const file of allSeries) {
        const item = document.createElement('div');
        item.className = 'legend-item';
        if (visibleSeries.get(file) === false) item.classList.add('inactive');
        const swatch = document.createElement('div');
        swatch.className = 'legend-swatch';
        swatch.style.background = color(file);
        const label = document.createElement('span');
        label.textContent = file;
        const offsetInput = document.createElement('input');
        offsetInput.type = 'number';
        offsetInput.step = '0.1';
        offsetInput.value = offsets.get(file) || 0;
        offsetInput.className = 'legend-offset';
        offsetInput.addEventListener('click', (e) => e.stopPropagation());
        offsetInput.addEventListener('input', () => {
          offsets.set(file, Number(offsetInput.value) || 0);
          renderChartFromData(lastData);
        });
        item.appendChild(swatch);
        item.appendChild(label);
        item.appendChild(offsetInput);
        item.addEventListener('click', () => {
          const current = visibleSeries.get(file);
          visibleSeries.set(file, current === false ? true : false);
          renderChartFromData(lastData);
        });
        chartLegend.appendChild(item);
      }

      const marker = g.append('g');
      const markerCircle = marker.append('circle').attr('r', 5).attr('stroke', '#111').attr('fill', 'none').attr('stroke-width', 2).style('display', 'none');
      const markerText = marker.append('text').attr('font-size', 12).attr('dx', 8).attr('dy', -8).style('display', 'none');

      svg.on('click', (event) => {
        const rect = svg.node().getBoundingClientRect();
        const px = event.clientX - rect.left - margin.left;
        const py = event.clientY - rect.top - margin.top;
        if (px < 0 || px > innerW || py < 0 || py > innerH) return;
        const xVal = x.invert(px);
        const yVal = y.invert(py);
        let closest = null;
        let bestDist = Infinity;
        for (const p of allPoints) {
          const dx = p.x - xVal;
          const dy = p.y - yVal;
          const dist = dx * dx + dy * dy;
          if (dist < bestDist) {
            bestDist = dist;
            closest = p;
          }
        }
        if (!closest) return;
        markerCircle
          .attr('cx', x(closest.x))
          .attr('cy', y(closest.y))
          .style('display', 'block');
        markerText
          .attr('x', x(closest.x))
          .attr('y', y(closest.y))
          .text(`${closest.file}: ${closest.x.toFixed(2)} / ${closest.y.toFixed(2)}`)
          .style('display', 'block');
        setStatus(`x=${closest.x.toFixed(2)}, y=${closest.y.toFixed(2)}, file=${closest.file}`);
      });

      chartEl.innerHTML = '';
      chartEl.appendChild(svg.node());
    }

    function setControlsEnabled(enabled) {
      refreshBtn.disabled = !enabled;
      saveCsvBtn.disabled = !enabled;
      xMinInput.disabled = !enabled;
      xMaxInput.disabled = !enabled;
      yMinInput.disabled = !enabled;
      yMaxInput.disabled = !enabled;
      chartRow.style.display = enabled ? 'grid' : 'none';
      document.getElementById('chartControls').classList.toggle('active', enabled);
      if (enabled) {
        xMaxInput.value = '4000';
        xMinInput.value = '500';
        yMinInput.value = '';
        yMaxInput.value = '';
        yMinInput.placeholder = t('yAuto') || 'auto';
        yMaxInput.placeholder = t('yAuto') || 'auto';
        visibleSeries = new Map();
      }
    }

    refreshBtn.addEventListener('click', () => {
      if (lastData) {
        renderChartFromData(lastData);
      }
    });
    xMinInput.addEventListener('input', () => lastData && renderChartFromData(lastData));
    xMaxInput.addEventListener('input', () => lastData && renderChartFromData(lastData));
    yMinInput.addEventListener('input', () => lastData && renderChartFromData(lastData));
    yMaxInput.addEventListener('input', () => lastData && renderChartFromData(lastData));

    saveCsvBtn.addEventListener('click', async () => {
      if (!lastCsvText) return;
      const defaultName = fileNameInput.value.trim() || 'merged.csv';
      const blob = new Blob([lastCsvText], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = defaultName.toLowerCase().endsWith('.csv') ? defaultName : `${defaultName}.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      setStatus(t('statusSaved')(defaultName));
    });

    mergeBtn.addEventListener('click', async () => {
      const files = Array.from(fileInput.files || []);
      if (!files.length) {
        setStatus(t('statusNoFiles'), true);
        return;
      }
      mergeBtn.disabled = true;
      setStatus(t('statusReading'));
      try {
        const payloadFiles = [];
        for (const f of files) {
          const content = await readFileText(f);
          payloadFiles.push({ name: f.name, content });
        }
        const downloadName = fileNameInput.value.trim() || 'merged.csv';

        // Local merge to wavenumber + per-file columns
        const parseInfraredText = (text) => {
          const rows = [];
          const lines = text.split(/\r?\n/);
          for (const raw of lines) {
            const line = raw.trim();
            if (!line) continue;
            const parts = line.split(/\s+/);
            if (parts.length >= 2 && !Number.isNaN(Number(parts[0])) && !Number.isNaN(Number(parts[1]))) {
              rows.push([Number(parts[0]), Number(parts[1])]);
            }
          }
          return rows;
        };

        const columns = payloadFiles.map((f) => f.name.replace(/[^a-zA-Z0-9_\-]+/g, '_') || 'col');
        const table = new Map();
        let totalRows = 0;
        payloadFiles.forEach((file, idx) => {
          const col = columns[idx];
          const rows = parseInfraredText(file.content);
          totalRows += rows.length;
          for (const [x, y] of rows) {
            const key = String(x);
            if (!table.has(key)) table.set(key, { x: Number(x), vals: new Map() });
            table.get(key).vals.set(col, y);
          }
        });

        const header = ['wavenumber', ...columns];
        const sorted = Array.from(table.values()).sort((a, b) => b.x - a.x);
        const lines = [header.join(',')];
        for (const row of sorted) {
          lines.push([
            row.x,
            ...columns.map((c) => (row.vals.has(c) ? row.vals.get(c) : '')),
          ].join(','));
        }

        const csvText = lines.join('\n');
        lastCsvText = csvText;
        setStatus(`${t('statusSending')} ${payloadFiles.length} files, ${totalRows} points...`);

        const parsed = d3.csvParse(csvText, d3.autoType);
        const cols = parsed.columns.map((c) => c.trim()).filter((c) => c && c !== 'wavenumber');
        if (!cols.length) {
          setStatus(t('statusNoDataCols'), true);
          return;
        }
        const series = [];
        for (const col of cols) {
          for (const row of parsed) {
            if (typeof row[col] === 'number' && typeof row.wavenumber === 'number') {
              series.push({ file: col, x: row.wavenumber, y: row[col] });
            }
          }
        }
        if (!series.length) {
          setStatus(t('statusNoNumeric'), true);
          return;
        }
        lastData = series;
        offsets = new Map();
        cols.forEach((col) => offsets.set(col, 0));
        if (!visibleSeries.size) {
          cols.forEach((col) => visibleSeries.set(col, true));
        }
        const finalName = downloadName.toLowerCase().endsWith('.csv') ? downloadName : `${downloadName}.csv`;
        if (autoDownloadInput.checked) {
          const blob = new Blob([csvText], { type: 'text/csv' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = finalName;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
          setStatus(t('statusDoneDownload'));
        } else {
          downloadLinkEl.innerHTML = '';
          const a = document.createElement('a');
          a.href = '#';
          a.textContent = `${finalName}`;
          a.addEventListener('click', (e) => {
            e.preventDefault();
            const blob = new Blob([csvText], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = finalName;
            document.body.appendChild(link);
            link.click();
            link.remove();
            URL.revokeObjectURL(url);
          });
          downloadLinkEl.appendChild(a);
          setStatus(t('statusDoneLink'));
        }

        setControlsEnabled(true);
        renderChartFromData(lastData);
      } catch (err) {
        console.error(err);
        setStatus(err.message, true);
      } finally {
        mergeBtn.disabled = false;
      }
    });
  </script>
</body>
</html>
